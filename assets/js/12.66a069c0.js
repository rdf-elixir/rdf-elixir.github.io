(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{410:function(e,t,r){"use strict";r.r(t);var o=r(33),s=Object(o.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"links"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#links"}},[e._v("#")]),e._v(" Links")]),e._v(" "),r("p",[e._v("As we saw in the last section, URIs can be kept in the "),r("code",[e._v("Grax.Schema")]),e._v("s "),r("code",[e._v("property")]),e._v(" values for the data properties as values with the "),r("code",[e._v(":iri")]),e._v(" datatype. But usually you aren't particularly interested on the URI, but on the description of the identified resource, you'll want to use them as object properties and map them to nested structs with the RDF descriptions of the RDF resources (nodes).")]),e._v(" "),r("p",[e._v("As we've said, object properties are still "),r("code",[e._v("Grax.Schema")]),e._v(" properties that are mapped to fields of an Elixir struct. But the values of these properties are mapped differently. As opposed to the values of data properties, which are mapped from RDF literal/XSD datatypes to values of simple Elixir datatypes, the value of object properties are "),r("code",[e._v("Grax.Schema")]),e._v(" structs, nested recursively to build up a tree structure under the root resource.")]),e._v(" "),r("p",[e._v("Before we get back to our graph diagram example, let's make a change in our diagram notation. We want to differentiate between leaf nodes with simple values and RDF literals from resource nodes whose description can itself be  put into a "),r("code",[e._v("Grax.Schema")]),e._v(" struct. So, in the following graph diagrams "),r("code",[e._v("Grax.Schema")]),e._v(" structs will be represented as diamond nodes. The URI in the node is the value of the "),r("code",[e._v("__id__")]),e._v(" field of the struct, while the other fields are the properties on the outgoing edges of the "),r("code",[e._v("Grax.Schema")]),e._v(" struct. So, the whole tree of the root node and its direct children are the "),r("code",[e._v("Grax.Schema")]),e._v(" struct. Think of "),r("code",[e._v("Grax.Schema")]),e._v(" structs as root nodes holding Elixir mappings of a subset of the RDF graph with statements directly or indirectly associated with our root node.")]),e._v(" "),r("p",[e._v("If we put the "),r("code",[e._v(":Address1")]),e._v(" resource as our first object property into the picture, we would get this if we would map the identifier to an ordinary "),r("code",[e._v("property")]),e._v(" in our schema.")]),e._v(" "),r("p",[r("img",{attrs:{src:"/img/user1-link1.png",alt:"img"}})]),e._v(" "),r("p",[e._v("The problem here is that we aren't actually interested in the identifier, in this case a blank node identifier, but the description of the resource it identifies. So, we'll embed the "),r("code",[e._v("Grax.Schema")]),e._v(" struct directly as value of the respective object property.")]),e._v(" "),r("p",[r("img",{attrs:{src:"/img/user1-link1-2.png",alt:"img"}})])])}),[],!1,null,null,null);t.default=s.exports}}]);