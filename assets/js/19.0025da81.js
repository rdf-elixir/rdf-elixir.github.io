(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{415:function(a,s,t){"use strict";t.r(s);var e=t(33),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"blank-nodes"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#blank-nodes"}},[a._v("#")]),a._v(" Blank nodes")]),a._v(" "),t("p",[a._v("Blank nodes are nodes of an RDF graph without an IRI. They are always local to that graph and mostly used as helper nodes.")]),a._v(" "),t("p",[a._v("They can be created with "),t("code",[a._v("RDF.BlankNode.new")]),a._v(" or its alias function "),t("code",[a._v("RDF.bnode")]),a._v(". You can either pass an atom, string, integer or Erlang reference with a custom local identifier or call it without any arguments, which will create a local identifier automatically.")]),a._v(" "),t("div",{staticClass:"language-elixir extra-class"},[t("pre",{pre:!0,attrs:{class:"language-elixir"}},[t("code",[t("span",{pre:!0,attrs:{class:"token module class-name"}},[a._v("RDF")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("bnode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token atom symbol"}},[a._v(":foo")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token module class-name"}},[a._v("RDF")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),t("span",{pre:!0,attrs:{class:"token function"}},[a._v("bnode")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),t("span",{pre:!0,attrs:{class:"token number"}},[a._v("42")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token module class-name"}},[a._v("RDF")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("bnode\n")])])]),t("p",[a._v("You can also use the "),t("code",[a._v("~B")]),a._v(" sigil to create a blank node with a custom name:")]),a._v(" "),t("div",{staticClass:"language-elixir extra-class"},[t("pre",{pre:!0,attrs:{class:"language-elixir"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("use")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token module class-name"}},[a._v("RDF")]),a._v("\n"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# or an explicit: import RDF.Sigils")]),a._v("\n\n~"),t("span",{pre:!0,attrs:{class:"token module class-name"}},[a._v("B")]),a._v("<foo"),t("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n")])])]),t("p",[a._v("The "),t("code",[a._v("~b")]),a._v(" sigil which supports string interpolation is also available:")]),a._v(" "),t("div",{staticClass:"language-elixir extra-class"},[t("pre",{pre:!0,attrs:{class:"language-elixir"}},[t("code",[t("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("use")]),a._v(" "),t("span",{pre:!0,attrs:{class:"token module class-name"}},[a._v("RDF")]),a._v("\n\n~"),t("span",{pre:!0,attrs:{class:"token module class-name"}},[a._v("B")]),a._v("<foo"),t("span",{pre:!0,attrs:{class:"token comment"}},[a._v("#{i}>")]),a._v("\n")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);