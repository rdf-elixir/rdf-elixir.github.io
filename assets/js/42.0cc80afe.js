(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{439:function(t,e,r){"use strict";r.r(e);var a=r(33),o=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"introduction"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[t._v("#")]),t._v(" Introduction")]),t._v(" "),r("p",[t._v("SPARQL.ex is an implementation of the "),r("a",{attrs:{href:"http://www.w3.org/TR/sparql11-overview/",target:"_blank",rel:"noopener noreferrer"}},[t._v("SPARQL"),r("OutboundLink")],1),t._v(" standards for Elixir. It allows to execute SPARQL queries against "),r("a",{attrs:{href:"/rdf-ex"}},[t._v("RDF.ex")]),t._v(" data structures.")]),t._v(" "),r("p",[t._v("The implementation of the "),r("a",{attrs:{href:"https://www.w3.org/TR/sparql11-protocol/",target:"_blank",rel:"noopener noreferrer"}},[t._v("SPARQL protocol"),r("OutboundLink")],1),t._v(" is separated into the "),r("code",[t._v("SPARQL.Client")]),t._v(" project. It executes SPARQL queries against any SPARQL 1.0/1.1-compatible endpoint over HTTP and supports result sets in both XML, JSON, CSV and TSV formats, with JSON being the preferred default for content-negotiation purposes.\nGraph results from "),r("code",[t._v("CONSTRUCT")]),t._v(" queries can be read in any serialization format supported by "),r("a",{attrs:{href:"/rdf-ex/serializations"}},[t._v("RDF.ex")]),t._v(" and will be directly deserialized to the respective "),r("a",{attrs:{href:"/rdf-ex/data-structures"}},[t._v("RDF.ex data structure")]),t._v(".")])])}),[],!1,null,null,null);e.default=o.exports}}]);