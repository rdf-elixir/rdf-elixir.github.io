(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{441:function(e,t,n){"use strict";n.r(t);var a=n(33),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"extension-functions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#extension-functions"}},[e._v("#")]),e._v(" Extension functions")]),e._v(" "),n("p",[e._v("The SPARQL query language has a specified way for the introduction of custom "),n("a",{attrs:{href:"https://www.w3.org/TR/sparql11-query/#extensionFunctions",target:"_blank",rel:"noopener noreferrer"}},[e._v("extension functions"),n("OutboundLink")],1),e._v(". An extension function for a function with the name "),n("code",[e._v("http://example.com/fun")]),e._v(" can be defined in SPARQL.ex like this:")]),e._v(" "),n("div",{staticClass:"language-elixir extra-class"},[n("pre",{pre:!0,attrs:{class:"language-elixir"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("defmodule")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token module class-name"}},[e._v("ExampleFunction")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("do")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("use")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token module class-name"}},[e._v("SPARQL")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),n("span",{pre:!0,attrs:{class:"token module class-name"}},[e._v("ExtensionFunction")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token attr-name"}},[e._v("name:")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token string"}},[e._v('"http://example.com/fun"')]),e._v("\n\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("def")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[e._v("call")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("distinct"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" arguments"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" _"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" execution"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("do")]),e._v("\n    "),n("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# your implementation")]),e._v("\n  "),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("end")]),e._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("end")]),e._v("\n")])])]),n("p",[e._v("The name of the module is arbitrary and has no further meaning. The first argument "),n("code",[e._v("distinct")]),e._v(" is a boolean flag telling, if the function was called with the "),n("code",[e._v("DISTINCT")]),e._v(" keyword, which is syntactically allowed in custom aggregate function calls only. The "),n("code",[e._v("arguments")]),e._v(" argument is the list of already evaluated RDF terms with which the extension function was called in the SPARQL query. The ignored third argument contains the currently evaluated solution and some other internal information and shouldn't be relied upon. Since the arguments are already evaluated against the current solution, this shouldn't be necessary anyway. The "),n("code",[e._v("execution")]),e._v(" argument is a map with some global query execution context information. In particular:")]),e._v(" "),n("ul",[n("li",[n("code",[e._v("base")]),e._v(": the base IRI")]),e._v(" "),n("li",[n("code",[e._v("time")]),e._v(": the query execution time")]),e._v(" "),n("li",[n("code",[e._v("bnode_generator")]),e._v(": the name of the "),n("code",[e._v("RDF.BlankNode.Generator")]),e._v(" (see "),n("a",{attrs:{href:"http://hexdocs.pm/rdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("RDF.ex documentation"),n("OutboundLink")],1),e._v(") used to generate unique blank nodes consistently")])]),e._v(" "),n("div",{staticClass:"custom-block danger"},[n("p",{staticClass:"custom-block-title"},[e._v("DANGER")]),e._v(" "),n("p",[e._v("Note that extension functions can of course only be used with queries run against RDF.ex data. For external SPARQL endpoints you'll have to live with the extension functions available on the underlying query engine used to run the SPARQL endpoint.")])])])}),[],!1,null,null,null);t.default=s.exports}}]);